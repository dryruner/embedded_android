1. Filesystem:
RAM disk filesystem (root file system /) is mounted as read-only. /cache, /data, and /system are typically mounted from separate partitions on actual storage media. Usually /cache and /data are mounted as read-write, while /system is mounted as read-only.
• Using a single filesystem:
There's nothing preventing you from using a single filesystem for all of Android's build output instead of using separate storage partitions. By using a single filesystem, you're assuming that you can update the entirety of the filesystem in one fell swoop. In sum, it'll be very difficult to create a fail-safe update procedure for your system.
* The SD card always appears as a block device and typically has a VFAT filesystem on it.
* The root directory:
See "Embedded Android" P179~180 for more details of every entry under /.

* /system:
/system/app: All modules built with BUILD_PACKAGE are here.
/system/bin: All modules built with BUILD_EXECUTABLE are here.
/system/framework: *.jar files. All modules built with BUILD_JAVA_LIBRARY are here.
/system/lib: The system's native libraries. All modules built with BUILD_SHARED_LIBRARY are here.
/system/build.prop: A set of properties generated during the build process of AOSP. They are loaded by init at startup.
(BUILD_PREBUILT: No default output location. Make sure you explicitly specify either LOCAL_MODULE_CLASS or LOCAL_MODULE_PATH.
 BUILD_KEY_CHAR_MAP: Output location is in /system/usr/keychars.
 )

* /data:
/data/app: Default install location for apps.
/data/app-private: Install location for apps with forward locking. (Developer can set the Copy Protection in the Publishing Options to On or Off. By setting it Off, the app's .apk can be copied off the device, while it can't if set to On. So On means the app is installed in /data/app-private/, and Off means it's installed in /data/app/.)
/data/property: Persistent system properties.
/data/tombstones: Whenever a native binary crashes, a file whose name is tombstone_seqnum is created here with information about the crash.

* Explicitly copying files:
In the case of some files, you don't need the build system to build them in any manner; you just need to copy the files into the filesystem. That's the purpose of the PRODUCT_COPY_FILES macro that you can use in the product's .mk. See "Embedded Android" P187.

* Default rights and ownership:
See system/core/include/private/android_filesystem_config.h. Every app is installed as a separate user. See "Embedded Android" P187 ~ P190 for more details.


2. adb:
Source code is in system/core/adb/. ADB server: on the host side. ADB daemon: on the device side.
To provide services, adb server opens socket 5037 on the host and listens for connections. Anyone can connect to the server as long as he respects the protocol. See OVERVIEW>TXT and SERVICES.TXT in system/core/adb/ if you'd like to implement code that talks directly to the adb server.
ADB can also interact with the emulator's console. See the port number on the upper-left corner of the emulator window. You could connect to the port number using telnet.
* Main flags and environment variables:
-d: Ensure that the command is executed on the device, not the emulator. Note that if more than 1 device is connected, it will return error.
-e: Ensure that the command is executed on the emulator.
-p <product_name or path>: Sometimes if ANDROID_PRODUCT_OUT is not set, you must use -p to indicate the path to the product's output directory within an AOSP source tree. (For example: $ adb -p XXX sync)

* adb connect <host>[:<port>]: Connect to a remote device whose adbd daemon is running on TCP/IP instead of USB. (5555 being the default port)
* adb disconnect <host>[:<port>]
* adb -d get-state
* adb -d get-serialno
* adb wait-for-device
* adb -d status-window
* adb -d bugreport; == adb -d shell dumpstate;
  (bugreport uses the dumpstate, actually. The difference is that: dumpstate needs to run as root; while bugreport has no such restriction. Essentially, bugreport causes init to start dumpstate in a mode where it opens a Unix domain socket and listens for connections for dumping its output. bugreport then connects to that socket and copies the content it reads to its own stdout, which is then proxied through adb to your host's shell. So it can bypass the root access.)
* adb -d forward <local> <remote>; e.g. $ adb forward tcp:8080 tcp:80; (If device is running a web server, you can browse the device on host's web browser through localhost:8080). $ adb forward tcp:8000 dev:/dev/ttyUSB0; (In this case, any read/write operations conducted on port 8000 will result in read/write operations on the remote /dev/ttyUSB0.)
adb forward's connection types:
	tcp:<port> - Regular TCP port.
	localfilesystem:<unix domain socket> - A regular Unix domain socket.
	localabstract:<unix domain socket> -  Like a Unix domain socket, but it's a Linux-specific extension.
	localreserved:<unix domain socket> - Android's "reserved" Unix domain sockets. They're all in /dev/socket.
	dev:<char device name> - Actual devices on the target.
	jdwp:<pid> - Used to specify the PID of a Dalvik process for debugging purposes.

* Dalvik debugging:
Dalvik implements the Java Debug Wire Protocol (JDWP), thereby allowing you to use the regular jdb to debug your apps. So you could use forward feature to debug the apps on the host:
	$ adb forward localhost:8000 jdwp:376
	$ jdb -attach localhost:8000
To know which PID are debuggable through JDWP, use:
	$ adb jdwp
Note that all of this requires that adbd be running on the target before any Dalvik app is started. Only those Dalvik apps that you start after adbd will be debuggable.

* adb sync:
Updating the entirety /data and /system partition. It will automatically find the files to sync if ANDROID_PRODUCT_OUT is set. Otherwise, you'll need to manually point it to the right output directory like (Using -p [path]):
	$ adb -d -p ~/bilbo/out/target/product/soho/ sync
You could also sync just the /system or /data partition, not both:
	$ adb -d data

* adb install:
	$ adb install [-l] [-r] [-s] <file>
	$ adb uninstall [-k] <package>
-l: Tells to ensure that the app is forward-locked. In other words, it disallows the user from copying the .apk off the device. (The app is installed in /data/app-private/ instead of /data/app/.)
-r: TO re-install the app, preserving its data as it is.
-s: To install the app on external storage (the SD card instead of internal storage)
-k: Tells uninstall to keep the app's data although the .apk is removed.

* adb reboot:
	$ adb reboot
	$ adb reboot bootloader // reboot into bootloader
	$ adb reboot recovery  // reboot into recovery mode
Note that all these reboot commands result into an immediate reboot. There's no graceful shutdown of any process or system services.

* Switching connection type:
adbd could also listens on TCP/IP instead of using USB.
	$ adb tcpip <port>; // restarting adbd in TCP mode on port. Essentially it will set the service.adb.tcp.port to <port> and restart the adbd daemon.
After that you could connect to it like:
	$ adb connect <ip> <port>
To switch it back to use USB, type:
	$ adb -s <ip>:<port> usb; // restarting adbd in USB mode

* Controlling the emulator:
You can connect to each emulator's console using telnet:
	$ telnet localhost <port>;
	$ help (in telnet's console)

* Tunneling PPP:
You can ask adb to set up a PPP connection between the host and the target. This might be for tethering or simply to create a network connection between the host and target when you have only a USB connection between the both. 
	$ adb ppp <adb service name> [ppp opts]
See "Embedded Android" P208 for more details about how to use ppp.
Also see: 
	pppd's man page
	ppp over adb
	device shows up in lsusb + adb but not in ifconfig
	USB tether for Xperia X10 Mini Pro
	creates a ppp link between my Ubuntu development machine and BeagleBoard running Android connected via USB.


3. Android's command line:
Source code is in system/core/sh/.
Toolbox's source code is in system/core/toolbox/.
Toolbox's common commands:
	hd: dump a file in hexadecimal format.
	id: print the current user and group IDs.
	ionice: Get/set the I/O priority of a process.
	lsmod: List the currently loaded kernel modules
	lsof: List the currently open file descriptors.
	netcfg: Network configuration.
	netstat: Print network statistics.
	printenv: Print all environment variables exported.
	renice: Change a process's nice value.
	route: Print/modify the kernel's routing table.

• Global properties:
	getprop <key>
	setprop <key> <value>
	watchprops
* Once a property has been set, you can change its value using setprop. You can't, however, delete a property that you created using setprop. The property will disappear at the next reboot unless its name starts with "persist.". In that case, a file with the property's full name will be created in /data/property/ containing the property's value. To delete a persist property, you need to delete this file in /data/property/ or destroy the /data partition.

* You can also monitor properties being changed in real-time:
	$ watchprops

• Input events:
The devices that expose Linux's input layer are available through entries in /dev/input/. While Android's system server already handles those events appropriately, you might want to either observe or generate your own events:
	$ getevent [-t] [-n] [-s <switchmask>] [-S] [-v <mask>] [-p] [-q] [-c <count>] [-r] [<device>]
	-t: show timestamps
	-n: don't print newlines
	-s: print switch states for given bits
	-S: print all switch states
	-v: verbose mask (errs=1, dev=2, name=4, info=8, vers=16, pos.events=32)
	-p: show possible events (errs, dev, name, info, pos.events)
	-q: quiet (clear verbose mask)
	-c: print given number of events then exit
	-r: print rate events are reveived

	$ sendevent <device> <type> <code> <value>; // e.g.: $ sendevent /dev/input/event0 1 330 1;
Note that getevent's output is hexadecimal, while sendevent's input is decimal.

• Controlling services:
	start <servicename>
	stop <servicename>
There's no way to ask Android for the list of running services. ($ service list could list system services, but not the customed services.)
	$ stop zygote; // This will stop all apps and kill the system server.

• Logging:
It allows you to add your own logs to Android's logger:
	$ log [-p <prioritychar>] [-t <tag>] <message>;
	-prioritychar: v,d,i,w,e
	e.g.:
	$ log -p i -t HEHE "nima"; // then run logcat, you'll see I/HEHE (...): nima
This can be useful if you have scripts to test/debug.

• ioctl:
	$ ioctl [-l <length>] [-a <argsize>] [-rdh] <device> <ioctlnr>
	-l <length>: length of io buffer
	-a <argsize>: size of each argument (1-8)
	-r: open device in read-only mode
	-d: direct argument (no iobuffer)
	-h: print help

• Wiping the device:
Sometimes it's necessary to destroy data on an Android device:
	$ wipe <system|data|all>

• Other Android-specific commands:
* nandread: Reading the contents of a NAND flash device to a file.
* newfs_msdos: Allowing you to format a device as a VFAT filesystem.
* notify: This command uses the inotify syscall to monitor directories or files for modification.
* r: This command just repeats the previous command you typed on the shell.
* schedtop: Like top, schedtop is for continuous real-time monitoring of the kernel's scheduler. 
* setconsole: This command lets you switch consoles.

• logcat:
	$ logcat [options] [filterspecs];
	options:
		-s: set default filter to silent. Like specifying filterspec "*:s"
		-f <filename>: Log to file, default to stdout.
		-r [<kbytes>]: Rotate log every kbytes (16 if unspecified). Requires -f.
		-n <count>: Set max number of rotated logs to <count>, default to 4.
		-v <format>: Set the log print format, where <format> is one of: brief, process, tag, thread, raw, time, threadtime, long.
		-c: clear the entire log and exit.
		-d: dump the log and then exit. (don't block)
		-t <count>: print only the most recent <count> lines. (implies -d)
		-g: get the size of the log's ring buffer and exit.
		-b <buffer>: request alternate ring buffer (main (default), radio, events)
		-B: output the log in binary.
	filterspecs:
		<tag>[:priority]
		-tag: A log component tag ('*' for all)
		-priority: V (verbose), D (debug), I (info), W (warn), E (error), F (fatal), S (silent, supress all output)
	Note that for filterspecs: '*' == '*:d'; and 'tag' == 'tag:v'. If not specified on the command line, filterspec is set from ANDROID_LOG_TAGS. If no filterspec is found, filter defaults to '*:I'. If not specified with -v, format is set from ANDROID_PRINTF_LOG or defaults to 'brief'.
* For example: $ logcat ActivityManager:I Myapp:D *:s; // Supressing all logs except those with the tag "ActivityManager" at priority 'I' and above, and all log messages with tag "Myapp" with priority 'D' and above.

• debuggerd:
This daemon is started by init early during startup. It opens the android:debuggerd abstract Unix domain socket and awaits connections. It remains dormant until a user-space process crashes. debuggerd then does two things: create a tombstone file in /data/tombstones/, and if required, allows debugging to be done through gdbserver.
* Also, if you set the debug.db.uid to some UID larger than that of the crashing process (just set a large integer value such as 2^31-1), debuggerd will then use the ptrace() syscall to attach to the dying process and allow you to start gdbserver to take control of it. Once gdbserver is attached to the dying process, you can then use one of the arm-eabigdb debuggers that are part of the AOSP's prebuilt/ directory to attach to the gdbserver running on the target.

• logwrapper:
This command allows you to run another command and redirect its stdout and stderr to the Android logger:
	$ logwrapper [-x] <binary> [<args> ...]
Using -x causes logwrapper to generate a segmentation fault (SIGSEGV) when binary terminates.

• run-as:
Allows you to run a binary as if it were executed with the rights associated with an app package:
	$ run-as <package-name> <command> [<args>]
The command will run from the directory associated with package-name in /data/app/ with that app's UID/GID.

• sdcard utility:
This utility uses Linux's FUSE to emulate in any directory on the filesystem the rights and permissions you'd find on any FAT-formatted SD card:
	$ sdcard <path> <uid> <gid>
The directory provided as path will be mounted to /mnt/sdcard/. And while sdcard must be issued as root, it'll run as /uid/gid. This is useful for devices that don'y actually have a removable SD card. The "external" storage is emulated on the "internal" storage using the sdcard command.

• Extra native utilities and daemons:
nc: netcat
sqlite3: SQLite
strace
tcpdump
oprofiled
cpueater: A while(1) loop, eating as much CPU as possible.
daemonize: Allows you to run it as a daemon in the background.
crasher: Packaged with debuggerd and essentially simulates a crashing process.
latencytop: Provides per-process latency information.
librank: Prints memory usage information for each object mapped into any process's memory.
procmem: Prints memory usage information for each section of a running PID.
procrank: Ranks processes by memory used.
schedtest: Tests the scheduler to see how reliable it is at promptly waking up tasks that request 1ms sleeps.
showmap: Prints out a process's memory map.
showslab: Prints out information on the slab allocator.
timeinfo: Reports realtime, uptime, awake percentage, and sleep percentage to the standard output.


4. Init:

