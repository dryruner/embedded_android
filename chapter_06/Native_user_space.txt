1. Filesystem:
RAM disk filesystem (root file system /) is mounted as read-only. /cache, /data, and /system are typically mounted from separate partitions on actual storage media. Usually /cache and /data are mounted as read-write, while /system is mounted as read-only.
• Using a single filesystem:
There's nothing preventing you from using a single filesystem for all of Android's build output instead of using separate storage partitions. By using a single filesystem, you're assuming that you can update the entirety of the filesystem in one fell swoop. In sum, it'll be very difficult to create a fail-safe update procedure for your system.
* The SD card always appears as a block device and typically has a VFAT filesystem on it.
* The root directory:
See "Embedded Android" P179~180 for more details of every entry under /.

* /system:
/system/app: All modules built with BUILD_PACKAGE are here.
/system/bin: All modules built with BUILD_EXECUTABLE are here.
/system/framework: *.jar files. All modules built with BUILD_JAVA_LIBRARY are here.
/system/lib: The system's native libraries. All modules built with BUILD_SHARED_LIBRARY are here.
/system/build.prop: A set of properties generated during the build process of AOSP. They are loaded by init at startup.
(BUILD_PREBUILT: No default output location. Make sure you explicitly specify either LOCAL_MODULE_CLASS or LOCAL_MODULE_PATH.
 BUILD_KEY_CHAR_MAP: Output location is in /system/usr/keychars.
 )

* /data:
/data/app: Default install location for apps.
/data/app-private: Install location for apps with forward locking. (Developer can set the Copy Protection in the Publishing Options to On or Off. By setting it Off, the app's .apk can be copied off the device, while it can't if set to On. So On means the app is installed in /data/app-private/, and Off means it's installed in /data/app/.)
/data/property: Persistent system properties.
/data/tombstones: Whenever a native binary crashes, a file whose name is tombstone_seqnum is created here with information about the crash.

* Explicitly copying files:
In the case of some files, you don't need the build system to build them in any manner; you just need to copy the files into the filesystem. That's the purpose of the PRODUCT_COPY_FILES macro that you can use in the product's .mk. See "Embedded Android" P187.

* Default rights and ownership:
See system/core/include/private/android_filesystem_config.h. Every app is installed as a separate user. See "Embedded Android" P187 ~ P190 for more details.


2. adb:
Source code is in system/core/adb/. ADB server: on the host side. ADB daemon: on the device side.
To provide services, adb server opens socket 5037 on the host and listens for connections. Anyone can connect to the server as long as he respects the protocol. See OVERVIEW>TXT and SERVICES.TXT in system/core/adb/ if you'd like to implement code that talks directly to the adb server.
ADB can also interact with the emulator's console. See the port number on the upper-left corner of the emulator window. You could connect to the port number using telnet.
* Main flags and environment variables:
-d: Ensure that the command is executed on the device, not the emulator. Note that if more than 1 device is connected, it will return error.
-e: Ensure that the command is executed on the emulator.
-p <product_name or path>: Sometimes if ANDROID_PRODUCT_OUT is not set, you must use -p to indicate the path to the product's output directory within an AOSP source tree. (For example: $ adb -p XXX sync)

* adb connect <host>[:<port>]: Connect to a remote device whose adbd daemon is running on TCP/IP instead of USB. (5555 being the default port)
* adb disconnect <host>[:<port>]
* adb -d get-state
* adb -d get-serialno
* adb wait-for-device
* adb -d status-window
* adb -d bugreport; == adb -d shell dumpstate;
  (bugreport uses the dumpstate, actually. The difference is that: dumpstate needs to run as root; while bugreport has no such restriction. Essentially, bugreport causes init to start dumpstate in a mode where it opens a Unix domain socket and listens for connections for dumping its output. bugreport then connects to that socket and copies the content it reads to its own stdout, which is then proxied through adb to your host's shell. So it can bypass the root access.)
* adb -d forward <local> <remote>; e.g. $ adb forward tcp:8080 tcp:80; (If device is running a web server, you can browse the device on host's web browser through localhost:8080). $ adb forward tcp:8000 dev:/dev/ttyUSB0; (In this case, any read/write operations conducted on port 8000 will result in read/write operations on the remote /dev/ttyUSB0.)
adb forward's connection types:
	tcp:<port> - Regular TCP port.
	localfilesystem:<unix domain socket> - A regular Unix domain socket.
	localabstract:<unix domain socket> -  Like a Unix domain socket, but it's a Linux-specific extension.
	localreserved:<unix domain socket> - Android's "reserved" Unix domain sockets. They're all in /dev/socket.
	dev:<char device name> - Actual devices on the target.
	jdwp:<pid> - Used to specify the PID of a Dalvik process for debugging purposes.

* Dalvik debugging:
Dalvik implements the Java Debug Wire Protocol (JDWP), thereby allowing you to use the regular jdb to debug your apps. So you could use forward feature to debug the apps on the host:
	$ adb forward localhost:8000 jdwp:376
	$ jdb -attach localhost:8000
To know which PID are debuggable through JDWP, use:
	$ adb jdwp
Note that all of this requires that adbd be running on the target before any Dalvik app is started. Only those Dalvik apps that you start after adbd will be debuggable.

* adb sync:
Updating the entirety /data and /system partition. It will automatically find the files to sync if ANDROID_PRODUCT_OUT is set. Otherwise, you'll need to manually point it to the right output directory like (Using -p [path]):
	$ adb -d -p ~/bilbo/out/target/product/soho/ sync
You could also sync just the /system or /data partition, not both:
	$ adb -d data

* adb install:
	$ adb install [-l] [-r] [-s] <file>
	$ adb uninstall [-k] <package>
-l: Tells to ensure that the app is forward-locked. In other words, it disallows the user from copying the .apk off the device. (The app is installed in /data/app-private/ instead of /data/app/.)
-r: TO re-install the app, preserving its data as it is.
-s: To install the app on external storage (the SD card instead of internal storage)
-k: Tells uninstall to keep the app's data although the .apk is removed.

* adb reboot:
	$ adb reboot
	$ adb reboot bootloader // reboot into bootloader
	$ adb reboot recovery  // reboot into recovery mode
Note that all these reboot commands result into an immediate reboot. There's no graceful shutdown of any process or system services.

* Switching connection type:
adbd could also listens on TCP/IP instead of using USB.
	$ adb tcpip <port>; // restarting adbd in TCP mode on port. Essentially it will set the service.adb.tcp.port to <port> and restart the adbd daemon.
After that you could connect to it like:
	$ adb connect <ip> <port>
To switch it back to use USB, type:
	$ adb -s <ip>:<port> usb; // restarting adbd in USB mode

* Controlling the emulator:
You can connect to each emulator's console using telnet:
	$ telnet localhost <port>;
	$ help (in telnet's console)

* Tunneling PPP:
You can ask adb to set up a PPP connection between the host and the target. This might be for tethering or simply to create a network connection between the host and target when you have only a USB connection between the both. 
	$ adb ppp <adb service name> [ppp opts]
See "Embedded Android" P208 for more details about how to use ppp.
Also see: 
	pppd's man page
	ppp over adb
	device shows up in lsusb + adb but not in ifconfig
	USB tether for Xperia X10 Mini Pro
	creates a ppp link between my Ubuntu development machine and BeagleBoard running Android connected via USB.


3. Android's command line:
Source code is in system/core/sh/.
Toolbox's source code is in system/core/toolbox/.
Toolbox's common commands:
	hd: dump a file in hexadecimal format.
	id: print the current user and group IDs.
	ionice: Get/set the I/O priority of a process.
	lsmod: List the currently loaded kernel modules
	lsof: List the currently open file descriptors.
	netcfg: Network configuration.
	netstat: Print network statistics.
	printenv: Print all environment variables exported.
	renice: Change a process's nice value.
	route: Print/modify the kernel's routing table.

• Global properties:
	getprop <key>
	setprop <key> <value>
	watchprops
* Once a property has been set, you can change its value using setprop. You can't, however, delete a property that you created using setprop. The property will disappear at the next reboot unless its name starts with "persist.". In that case, a file with the property's full name will be created in /data/property/ containing the property's value. To delete a persist property, you need to delete this file in /data/property/ or destroy the /data partition.

* You can also monitor properties being changed in real-time:
	$ watchprops

• Input events:

